using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Linq;
using HarmonyLib;
using BepInEx;
using BepInEx.Configuration;
using BepInEx.Unity.IL2CPP;
using BepInEx.Logging;
using UnityEngine;
using UnityEngine.Networking;
using System.Runtime.CompilerServices;

namespace SecretFlasher.VoicePack_Plus
{
    public static class PluginInfo
    {
        public const string GUID = "Havoc12.secretflasher.voicepack.plus";
        public const string Name = "SecretFlasher.VoicePack-Plus";
        public const string Version = "1.7.0";
    }

    [BepInPlugin(PluginInfo.GUID, PluginInfo.Name, PluginInfo.Version)]
    public class VoicePackPlugin : BasePlugin
    {
        public static VoicePackPlugin Instance { get; private set; }
        public static ManualLogSource L;

        private ConfigFile _customConfig;
        private int _frameCounter = 0;

        private GameObject _audioHost;
        private AudioSource _audioSource;
        private readonly Dictionary<string, List<AudioClip>> _audioClips = new()
        {
            { "low", new List<AudioClip>() },
            { "medium", new List<AudioClip>() },
            { "high", new List<AudioClip>() },
            { "climax", new List<AudioClip>() }
        };
        private readonly System.Random _rng = new System.Random();

        // 核心修改：每个阶段维护可用的音频索引列表（用于轮询）
        private readonly Dictionary<string, List<int>> _availableClipIndicesPerStage = new()
        {
            { "low", new List<int>() },
            { "medium", new List<int>() },
            { "high", new List<int>() },
            { "climax", new List<int>() }
        };

        private bool _preloadQueued = false;
        private readonly Queue<(string path, string category)> _loadQueue = new();
        private struct PendingLoad { public string path; public string category; public UnityWebRequest request; }
        private readonly List<PendingLoad> _inflightLoads = new();
        private const int MaxInflightLoads = 4;
        private readonly HashSet<string> _warnedEmptyCategories = new();
        private readonly Dictionary<string, float> _lastReloadAttempt = new()
        {
            { "low", -999f }, { "medium", -999f }, { "high", -999f }, { "climax", -999f }
        };

        private float _previousEcstasy = 0f;
        private int _currentLevel = -1;
        private float _nextPlayTime = -999f;
        private bool _climaxPlayed = false;
        private float _lastLowPlayed = -999f;
        private float _lastMediumPlayed = -999f;
        private float _lastHighPlayed = -999f;
        private float _lastClimaxPlayed = -999f;
        private float _lastAnyAudioPlayed = -999f;
        public float CurrentPlayerEcstasy { get; private set; } = 0f;

        private FieldInfo _lastAddEcstasyTimeField;
        private PropertyInfo _lastAddEcstasyTimeProperty;
        private bool _loggedFieldSearchDebug = false;
        private float _lastEcstasyChangeTime = -1f;
        private float _currentGrowthRate = 0f;

        private const string GameStateTypeName = "ExposureUnnoticed2.Scripts.InGame.GameState";
        private const string GameStateDataTypeName = "ExposureUnnoticed2.Scripts.InGame.GameStateData";
        private const string PlayerEcstasyControllerTypeName = "ExposureUnnoticed2.Object3D.Player.Scripts.PlayerEcstasyController";
        private const string PreferredEcstasyMember = "PlayerEcstasy";

        private Type _gameStateType;
        private Type _gameStateDataType;
        private object _gameStateDataInstance;
        private Func<object> _gameStateDataGetter;
        private Func<object, float> _ecstasyValueGetter;
        private bool _reflectionInitialized = false;

        private bool _controllerGetterAttempted = false;
        private Func<object, float> _controllerEcstasyGetter;
        private Func<float> _fallbackEcstasyGetter;
        private float _lastDirectEcstasyFeed = -999f;

        private float _lastNotFoundLog = -999f;
        private float _lastEcstasyLogValue = -1f;

        // 核心配置项
        private ConfigEntry<float> _cfgLowBaseInterval;
        private ConfigEntry<float> _cfgMediumBaseInterval;
        private ConfigEntry<float> _cfgHighBaseInterval;
        private ConfigEntry<float> _cfgClimaxCooldown;
        private ConfigEntry<float> _cfgGrowthRateSensitivity;
        private ConfigEntry<float> _cfgMinPlayInterval;
        private ConfigEntry<float> _cfgMaxPlayInterval;
        private ConfigEntry<float> _cfgLowThreshold;
        private ConfigEntry<float> _cfgMediumThreshold;
        private ConfigEntry<float> _cfgHighThreshold;
        private ConfigEntry<float> _cfgClimaxThreshold;
        private ConfigEntry<float> _cfgResetThreshold;
        private ConfigEntry<float> _cfgHysteresis;
        private ConfigEntry<float> _cfgGrowthTimeout;

        // 调试配置项
        private ConfigEntry<bool> _cfgEnableDebugLogging;
        private ConfigEntry<bool> _cfgEnableVerboseEcstasyLogging;

        public override void Load()
        {
            Instance = this;
            L = Log;

            _customConfig = new ConfigFile(Path.Combine(Paths.ConfigPath, "secretflasher.voicepack.plus.cfg"), true);

            string startupTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
            L.LogInfo($"[{startupTime}] {PluginInfo.Name} v{PluginInfo.Version} loaded - Integrated growth rate calculation + stage switch cooldown + audio round-robin playback");
            L.LogInfo($"[{startupTime}] Custom config file: {_customConfig.ConfigFilePath}");

            InitializeConfiguration();
            InitializeAudioSystem();
            InitializeReflection();
            ApplyHarmonyPatches();
        }

        #region 初始化方法
        private void InitializeConfiguration()
        {
            _cfgEnableDebugLogging = _customConfig.Bind(
                "Debug",
                "EnableDebugLogging",
                false,
                "Enables debug level logging (verbose technical details)");

            _cfgEnableVerboseEcstasyLogging = _customConfig.Bind(
                "Debug",
                "EnableVerboseEcstasyLogging",
                false,
                "Enables frame-by-frame logging of Ecstasy values (very verbose)");

            _cfgLowBaseInterval = _customConfig.Bind("Playback", "LowBaseInterval", 1.2f, "Low level base playback interval (seconds)");
            _cfgMediumBaseInterval = _customConfig.Bind("Playback", "MediumBaseInterval", 1.0f, "Medium level base playback interval (seconds)");
            _cfgHighBaseInterval = _customConfig.Bind("Playback", "HighBaseInterval", 1.0f, "High level base playback interval (seconds)");
            _cfgClimaxCooldown = _customConfig.Bind("Playback", "ClimaxCooldown", 5.0f, "Climax audio cooldown (seconds)");
            _cfgGrowthRateSensitivity = _customConfig.Bind("GrowthRate", "Sensitivity", 0.4f, "How much growth rate affects playback speed (0-2)");
            _cfgMinPlayInterval = _customConfig.Bind("GrowthRate", "MinPlayInterval", 0.3f, "Minimum allowed playback interval (seconds)");
            _cfgMaxPlayInterval = _customConfig.Bind("GrowthRate", "MaxPlayInterval", 3.0f, "Maximum allowed playback interval (seconds)");

            _cfgLowThreshold = _customConfig.Bind("Thresholds", "LowThreshold", 0.0001f, "Low level threshold (0-1)");
            _cfgMediumThreshold = _customConfig.Bind("Thresholds", "MediumThreshold", 0.4f, "Medium level threshold (0-1)");
            _cfgHighThreshold = _customConfig.Bind("Thresholds", "HighThreshold", 0.7f, "High level threshold (0-1)");
            _cfgClimaxThreshold = _customConfig.Bind("Thresholds", "ClimaxThreshold", 1.0f, "Climax level threshold (0-1)");
            _cfgResetThreshold = _customConfig.Bind("Thresholds", "ResetThreshold", 0.1f, "State reset threshold (0-1)");
            _cfgHysteresis = _customConfig.Bind("Thresholds", "Hysteresis", 0.08f, "Level switch hysteresis (0-0.1)");
            _cfgGrowthTimeout = _customConfig.Bind(
                "Thresholds",
                "GrowthTimeout",
                1f,
                "Time (seconds) after which audio stops if Ecstasy doesn't grow (0 = disable this check)");

            string configTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
            L.LogInfo($"[{configTime}] Configuration initialized - LowThreshold set to {_cfgLowThreshold.Value:F2}, MinPlayInterval: {_cfgMinPlayInterval.Value:F2}s");

            if (_cfgEnableDebugLogging.Value)
            {
                L.LogDebug($"[{configTime}] Debug logging enabled");
                L.LogDebug($"[{configTime}] Verbose Ecstasy logging: {(_cfgEnableVerboseEcstasyLogging.Value ? "ENABLED" : "DISABLED")}");
            }
        }

        private void InitializeAudioSystem()
        {
            _audioHost = new GameObject("VoicePack_AudioHost");
            GameObject.DontDestroyOnLoad(_audioHost);
            _audioSource = _audioHost.AddComponent<AudioSource>();
            _audioSource.playOnAwake = false;
            _audioSource.spatialBlend = 0f;

            string audioInitTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
            L.LogInfo($"[{audioInitTime}] Audio system initialized");

            if (_cfgEnableDebugLogging.Value)
            {
                L.LogDebug($"[{audioInitTime}] Audio host object created: {_audioHost.name}");
            }
        }

        private void InitializeReflection()
        {
            if (_reflectionInitialized) return;

            try
            {
                _gameStateType = AccessTools.TypeByName(GameStateTypeName) ??
                    AppDomain.CurrentDomain.GetAssemblies()
                        .SelectMany(a => a.GetTypes())
                        .FirstOrDefault(t => t.Name == "GameState" && !t.IsEnum && !t.IsValueType);

                _gameStateDataType = AccessTools.TypeByName(GameStateDataTypeName);
                if (_gameStateDataType == null)
                {
                    string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogError($"[{errorTime}] Failed to find GameStateData type");
                    _reflectionInitialized = true;
                    return;
                }

                if (_gameStateType != null)
                {
                    var prop = _gameStateType.GetProperty("GameStateData", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
                    if (prop != null && prop.PropertyType == _gameStateDataType)
                    {
                        var getMethod = prop.GetGetMethod(true);
                        _gameStateDataGetter = () => getMethod.Invoke(null, null);

                        if (_cfgEnableDebugLogging.Value)
                        {
                            string debugTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                            L.LogDebug($"[{debugTime}] Bound GameStateData via property");
                        }
                    }
                    else
                    {
                        var field = _gameStateType.GetField("GameStateData", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
                        if (field != null && field.FieldType == _gameStateDataType)
                        {
                            _gameStateDataGetter = () => field.GetValue(null);

                            if (_cfgEnableDebugLogging.Value)
                            {
                                string debugTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                                L.LogDebug($"[{debugTime}] Bound GameStateData via field");
                            }
                        }
                    }
                }

                var ecstasyProp = _gameStateDataType.GetProperty(PreferredEcstasyMember, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (ecstasyProp != null && (ecstasyProp.PropertyType == typeof(float) || ecstasyProp.PropertyType == typeof(double)))
                {
                    var getMethod = ecstasyProp.GetGetMethod(true);
                    _ecstasyValueGetter = obj => Convert.ToSingle(getMethod.Invoke(obj, null));

                    if (_cfgEnableDebugLogging.Value)
                    {
                        string debugTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                        L.LogDebug($"[{debugTime}] Bound PlayerEcstasy via property");
                    }
                }
                else
                {
                    var ecstasyField = _gameStateDataType.GetField(PreferredEcstasyMember, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                    if (ecstasyField != null && (ecstasyField.FieldType == typeof(float) || ecstasyField.FieldType == typeof(double)))
                    {
                        _ecstasyValueGetter = obj => Convert.ToSingle(ecstasyField.GetValue(obj));

                        if (_cfgEnableDebugLogging.Value)
                        {
                            string debugTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                            L.LogDebug($"[{debugTime}] Bound PlayerEcstasy via field");
                        }
                    }
                }

                if (_ecstasyValueGetter == null)
                {
                    string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogError($"[{errorTime}] Failed to bind PlayerEcstasy value getter");
                }
                else
                {
                    string reflectionTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogInfo($"[{reflectionTime}] Reflection initialized successfully - Bound PlayerEcstasy member");
                }
            }
            catch (Exception ex)
            {
                string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogError($"[{errorTime}] Reflection initialization failed: {ex.Message}");

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{errorTime}] Reflection exception details: {ex.StackTrace}");
                }
            }

            _reflectionInitialized = true;
        }

        private void ApplyHarmonyPatches()
        {
            try
            {
                var harmony = new Harmony(PluginInfo.GUID);

                var controllerType = AccessTools.TypeByName(PlayerEcstasyControllerTypeName);
                if (controllerType != null)
                {
                    var onUpdateMethod = AccessTools.Method(controllerType, "OnUpdate", Type.EmptyTypes);
                    if (onUpdateMethod != null)
                    {
                        harmony.Patch(onUpdateMethod, postfix: new HarmonyMethod(typeof(VoicePackPlugin), nameof(OnPlayerEcstasyControllerUpdate)));
                        string patchTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                        L.LogInfo($"[{patchTime}] Patched PlayerEcstasyController.OnUpdate");
                    }
                    else
                    {
                        string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                        L.LogWarning($"[{warnTime}] Failed to find PlayerEcstasyController.OnUpdate method");
                    }
                }
                else
                {
                    string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogWarning($"[{warnTime}] Failed to find PlayerEcstasyController type");
                }

                string skipPatchTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogInfo($"[{skipPatchTime}] Skipped set_PlayerEcstasy patch (IL2CPP field accessor cannot be patched)");
            }
            catch (Exception ex)
            {
                string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogError($"[{errorTime}] Harmony patch application failed: {ex.Message}");

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{errorTime}] Patch exception details: {ex.StackTrace}");
                }
            }
        }
        #endregion

        #region 核心逻辑
        internal void Tick(object controllerInstance = null)
        {
            _frameCounter++;
            string frameTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
            float unityTime = Time.realtimeSinceStartup;

            EnsureAudioSourceValid();
            EnsureAudioPreloaded();
            ProcessAudioLoadQueue();

            if (controllerInstance != null && (_lastAddEcstasyTimeField == null && _lastAddEcstasyTimeProperty == null))
            {
                ResolveLastAddEcstasyTimeField(controllerInstance);
            }

            float currentEcstasy = GetCurrentEcstasyValue(controllerInstance);

            if (currentEcstasy >= 0f)
            {
                if (_cfgEnableVerboseEcstasyLogging.Value)
                {
                    L.LogInfo($"[{frameTime}] [UnityTime: {unityTime:F3}s] Frame: {_frameCounter}, Ecstasy Value: {currentEcstasy:F4} (Previous: {_previousEcstasy:F4})");
                }

                if (_cfgEnableDebugLogging.Value && Mathf.Abs(currentEcstasy - _lastEcstasyLogValue) > 0.001f)
                {
                    L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Ecstasy updated: {_lastEcstasyLogValue:F4} → {currentEcstasy:F4}");
                    _lastEcstasyLogValue = currentEcstasy;
                }
            }
            else
            {
                L.LogWarning($"[{frameTime}] [UnityTime: {unityTime:F3}s] Frame: {_frameCounter}, Invalid Ecstasy Value (current: {currentEcstasy:F4})");
                LogNotFoundThrottled("No valid ecstasy value found");
                return;
            }

            if (currentEcstasy > _previousEcstasy && _previousEcstasy >= 0)
            {
                _lastEcstasyChangeTime = unityTime;

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Ecstasy increased: {_previousEcstasy:F4} → {currentEcstasy:F4}, updated change time (new: {_lastEcstasyChangeTime:F3}s)");
                }
            }

            CalculateGrowthRate(controllerInstance, currentEcstasy, unityTime, frameTime);
            UpdateStateMachine(currentEcstasy, unityTime, frameTime);

            _previousEcstasy = currentEcstasy;
        }

        private float GetCurrentEcstasyValue(object controllerInstance)
        {
            if (_reflectionInitialized && _gameStateDataGetter != null && _ecstasyValueGetter != null)
            {
                try
                {
                    _gameStateDataInstance = _gameStateDataGetter();
                    if (_gameStateDataInstance != null)
                    {
                        float value = _ecstasyValueGetter(_gameStateDataInstance);
                        CurrentPlayerEcstasy = Mathf.Clamp01(value);
                        return CurrentPlayerEcstasy;
                    }
                    else if (_cfgEnableDebugLogging.Value)
                    {
                        L.LogDebug($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] GameStateData instance is null");
                    }
                }
                catch (Exception ex)
                {
                    string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogWarning($"[{errorTime}] Failed to get ecstasy from GameStateData: {ex.Message}");

                    if (_cfgEnableDebugLogging.Value)
                    {
                        L.LogDebug($"[{errorTime}] GameStateData exception: {ex.StackTrace}");
                    }
                }
            }

            if (controllerInstance != null)
            {
                if (!_controllerGetterAttempted)
                {
                    TryResolveControllerEcstasyGetter(controllerInstance.GetType());
                    _controllerGetterAttempted = true;
                }

                if (_controllerEcstasyGetter != null)
                {
                    try
                    {
                        float value = Mathf.Clamp01(_controllerEcstasyGetter(controllerInstance));
                        CurrentPlayerEcstasy = value;
                        return value;
                    }
                    catch (Exception ex)
                    {
                        if (_cfgEnableDebugLogging.Value)
                        {
                            L.LogDebug($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] Controller getter exception: {ex.Message}");
                        }
                    }
                }

                if (_fallbackEcstasyGetter == null)
                {
                    TryFuzzyEcstasySearch(controllerInstance);
                }

                if (_fallbackEcstasyGetter != null)
                {
                    try
                    {
                        float value = Mathf.Clamp01(_fallbackEcstasyGetter());
                        CurrentPlayerEcstasy = value;
                        return value;
                    }
                    catch
                    {
                        _fallbackEcstasyGetter = null;
                        if (_cfgEnableDebugLogging.Value)
                        {
                            L.LogDebug($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] Fallback getter failed, resetting");
                        }
                    }
                }
            }

            return -1f;
        }

        private void UpdateStateMachine(float currentEcstasy, float unityTime, string frameTime)
        {
            // Climax逻辑
            if (currentEcstasy >= _cfgClimaxThreshold.Value)
            {
                _currentLevel = 3;
                if (!_climaxPlayed && unityTime - _lastClimaxPlayed >= _cfgClimaxCooldown.Value)
                {
                    // 检查全局冷却
                    float timeSinceLastPlay = unityTime - _lastAnyAudioPlayed;
                    if (timeSinceLastPlay >= _cfgMinPlayInterval.Value)
                    {
                        L.LogInfo($"[{frameTime}] [UnityTime: {unityTime:F3}s] Climax threshold reached - playing climax audio (Ecstasy: {currentEcstasy:F4})");
                        PlayAudio("climax", unityTime);
                        _lastClimaxPlayed = unityTime;
                        _climaxPlayed = true;
                    }
                    else
                    {
                        if (_cfgEnableDebugLogging.Value)
                        {
                            L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Climax audio delayed: last play was {timeSinceLastPlay:F3}s ago (needs {_cfgMinPlayInterval.Value:F3}s)");
                        }
                        _nextPlayTime = _lastAnyAudioPlayed + _cfgMinPlayInterval.Value;
                    }
                }
                return;
            }

            // 重置逻辑
            if (currentEcstasy <= _cfgResetThreshold.Value)
            {
                if (_currentLevel != -1)
                {
                    L.LogInfo($"[{frameTime}] [UnityTime: {unityTime:F3}s] Resetting state (ecstasy: {currentEcstasy:F4}, CurrentLevel: {_currentLevel})");
                    // 重置所有阶段的可用索引列表
                    foreach (var key in _availableClipIndicesPerStage.Keys.ToList())
                    {
                        ResetAvailableIndicesForStage(key);
                    }
                    _currentLevel = -1;
                    _climaxPlayed = false;
                    _nextPlayTime = -999f;
                    _lastAnyAudioPlayed = -999f;
                }
                return;
            }

            // 等级判断
            int newLevel = GetLevelFromEcstasy(currentEcstasy);
            bool shouldSwitch = false;

            if (newLevel > _currentLevel)
            {
                shouldSwitch = true;
            }
            else if (newLevel < _currentLevel)
            {
                shouldSwitch = (GetLevelThreshold(_currentLevel) - currentEcstasy) > _cfgHysteresis.Value * 2;
            }

            // 等级切换逻辑
            if (shouldSwitch)
            {
                string oldLevelName = GetLevelName(_currentLevel);
                string newLevelName = GetLevelName(newLevel);
                L.LogInfo($"[{frameTime}] [UnityTime: {unityTime:F3}s] Level changed: {_currentLevel} → {newLevel} ({newLevelName}) | Growth rate: {_currentGrowthRate:F4} times/sec | Ecstasy: {currentEcstasy:F4}");

                // 重置新阶段的可用索引列表（跨阶段重置）
                ResetAvailableIndicesForStage(newLevelName);

                _currentLevel = newLevel;

                // 检查全局冷却间隔
                float timeSinceLastPlay = unityTime - _lastAnyAudioPlayed;
                if (timeSinceLastPlay >= _cfgMinPlayInterval.Value)
                {
                    PlayCurrentLevelAudio(unityTime, currentEcstasy);
                    SetNextPlayTime(unityTime);
                }
                else
                {
                    float delay = _cfgMinPlayInterval.Value - timeSinceLastPlay;
                    _nextPlayTime = unityTime + delay;

                    if (_cfgEnableDebugLogging.Value)
                    {
                        L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Level switch cooldown: delaying {newLevelName} audio by {delay:F3}s (next play at {_nextPlayTime:F3}s)");
                    }
                }
            }
            else if (_currentLevel != -1 && unityTime >= _nextPlayTime)
            {
                PlayCurrentLevelAudio(unityTime, currentEcstasy);
                SetNextPlayTime(unityTime);
            }
        }
        #endregion

        #region 增速计算
        private void ResolveLastAddEcstasyTimeField(object controllerInstance)
        {
            if (controllerInstance == null) return;
            Type controllerType = controllerInstance.GetType();
            var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;

            var possibleNames = new[] { "lastAddEcstasyTime", "LastAddEcstasyTime", "_lastAddEcstasyTime", "lastEcstasyAddTime" };
            foreach (var name in possibleNames)
            {
                _lastAddEcstasyTimeField = controllerType.GetField(name, flags);
                if (_lastAddEcstasyTimeField != null && _lastAddEcstasyTimeField.FieldType == typeof(float))
                {
                    string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogInfo($"[{bindTime}] Successfully bound field: {controllerType.Name}.{name}");
                    return;
                }
            }

            foreach (var name in possibleNames)
            {
                _lastAddEcstasyTimeProperty = controllerType.GetProperty(name, flags);
                if (_lastAddEcstasyTimeProperty != null && _lastAddEcstasyTimeProperty.PropertyType == typeof(float) && _lastAddEcstasyTimeProperty.CanRead)
                {
                    string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogInfo($"[{bindTime}] Successfully bound property: {controllerType.Name}.{name}");
                    return;
                }
            }

            if (!_loggedFieldSearchDebug)
            {
                _loggedFieldSearchDebug = true;
                string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogWarning($"[{warnTime}] Failed to find lastAddEcstasyTime in {controllerType.FullName}");

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogWarning("=== Available fields (for debugging): ===");
                    foreach (var field in controllerType.GetFields(flags).OrderBy(f => f.Name))
                    {
                        L.LogWarning($"Field: {field.Name} ({field.FieldType.Name})");
                    }
                    L.LogWarning("=== Available properties (for debugging): ===");
                    foreach (var prop in controllerType.GetProperties(flags).OrderBy(p => p.Name))
                    {
                        L.LogWarning($"Property: {prop.Name} ({prop.PropertyType.Name})");
                    }
                    L.LogWarning("=== End of debug info ===");
                }
            }
        }

        private float GetLastAddEcstasyTimeValue(object controllerInstance)
        {
            if (_lastAddEcstasyTimeField != null && controllerInstance != null)
            {
                try
                {
                    return (float)_lastAddEcstasyTimeField.GetValue(controllerInstance);
                }
                catch (Exception ex)
                {
                    string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogError($"[{errorTime}] Failed to get lastAddEcstasyTime from field: {ex.Message}");

                    if (_cfgEnableDebugLogging.Value)
                    {
                        L.LogDebug($"[{errorTime}] Field access exception: {ex.StackTrace}");
                    }
                }
            }

            if (_lastAddEcstasyTimeProperty != null && controllerInstance != null)
            {
                try
                {
                    return (float)_lastAddEcstasyTimeProperty.GetValue(controllerInstance);
                }
                catch (Exception ex)
                {
                    string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogError($"[{errorTime}] Failed to get lastAddEcstasyTime from property: {ex.Message}");

                    if (_cfgEnableDebugLogging.Value)
                    {
                        L.LogDebug($"[{errorTime}] Property access exception: {ex.StackTrace}");
                    }
                }
            }

            return _lastEcstasyChangeTime;
        }

        private void CalculateGrowthRate(object controllerInstance, float currentEcstasy, float unityTime, string frameTime)
        {
            float lastAddTime = GetLastAddEcstasyTimeValue(controllerInstance);

            if (_lastAddEcstasyTimeField == null && _lastAddEcstasyTimeProperty == null)
            {
                if (currentEcstasy > _previousEcstasy && _previousEcstasy >= 0)
                {
                    _lastEcstasyChangeTime = _lastEcstasyChangeTime < 0 ? unityTime : _lastEcstasyChangeTime;
                }
                lastAddTime = _lastEcstasyChangeTime;
            }

            if (lastAddTime < 0)
            {
                _currentGrowthRate = 0f;

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Growth rate reset to 0 - invalid lastAddTime ({lastAddTime:F3}s)");
                }
                return;
            }

            float timeDelta = unityTime - lastAddTime;

            if (timeDelta < 0.001f || timeDelta > 10f)
            {
                _currentGrowthRate = 0f;

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Invalid time delta: {timeDelta:F3}s (growth rate reset to 0)");
                }
                return;
            }

            _currentGrowthRate = 1f / timeDelta;

            if (_cfgEnableDebugLogging.Value)
            {
                L.LogDebug($"[{frameTime}] [UnityTime: {unityTime:F3}s] Growth rate calculated: {_currentGrowthRate:F4} times/sec (timeDelta: {timeDelta:F3}s, lastAddTime: {lastAddTime:F3}s)");
            }
        }
        #endregion

        #region 音频播放（核心升级：轮询所有音频后再重复）
        // 新增：重置指定阶段的可用索引列表（随机打乱）
        private void ResetAvailableIndicesForStage(string stage)
        {
            if (!_audioClips.ContainsKey(stage)) return;
            var clips = _audioClips[stage].Where(c => c != null).ToList();
            _availableClipIndicesPerStage[stage].Clear();

            // 生成0到count-1的索引
            for (int i = 0; i < clips.Count; i++)
            {
                _availableClipIndicesPerStage[stage].Add(i);
            }

            // 随机打乱索引，实现随机轮询（而非顺序轮询）
            ShuffleList(_availableClipIndicesPerStage[stage]);

            if (_cfgEnableDebugLogging.Value)
            {
                string logTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogDebug($"[{logTime}] Reset available indices for {stage} stage: {string.Join(", ", _availableClipIndicesPerStage[stage])} (total: {clips.Count} clips)");
            }
        }

        // 新增：列表洗牌算法（Fisher-Yates）
        private void ShuffleList<T>(List<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = _rng.Next(n + 1);
                T value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

        private void EnsureAudioPreloaded()
        {
            if (_preloadQueued) return;
            _preloadQueued = true;

            string baseAudioPath = Path.Combine(Paths.PluginPath, PluginInfo.Name, "VoicePack");
            if (!Directory.Exists(baseAudioPath))
            {
                string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogWarning($"[{warnTime}] Audio base directory not found: {baseAudioPath}");
                return;
            }

            foreach (var category in new[] { "low", "medium", "high", "climax" })
            {
                string categoryPath = Path.Combine(baseAudioPath, category);
                if (!Directory.Exists(categoryPath))
                {
                    string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogWarning($"[{warnTime}] Audio category directory not found: {categoryPath}");
                    continue;
                }

                var audioFiles = Directory.GetFiles(categoryPath, "*.*")
                    .Where(f => f.EndsWith(".wav", StringComparison.OrdinalIgnoreCase) || f.EndsWith(".ogg", StringComparison.OrdinalIgnoreCase))
                    .ToList();

                if (audioFiles.Count == 0)
                {
                    string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogWarning($"[{warnTime}] No audio files found in {categoryPath} (supports .wav/.ogg)");
                    continue;
                }

                string loadTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogInfo($"[{loadTime}] Found {audioFiles.Count} audio files for {category} category");

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{loadTime}] Audio files for {category}: {string.Join(", ", audioFiles.Select(Path.GetFileName))}");
                }

                foreach (var file in audioFiles)
                {
                    _loadQueue.Enqueue((file, category));
                }
            }
        }

        private void ProcessAudioLoadQueue()
        {
            while (_inflightLoads.Count < MaxInflightLoads && _loadQueue.Count > 0)
            {
                var item = _loadQueue.Dequeue();
                string url = "file:///" + item.path.Replace('\\', '/');
                AudioType audioType = Path.GetExtension(item.path).ToLowerInvariant() switch
                {
                    ".wav" => AudioType.WAV,
                    ".ogg" => AudioType.OGGVORBIS,
                    _ => AudioType.UNKNOWN
                };

                var request = UnityWebRequestMultimedia.GetAudioClip(url, audioType);
                request.SendWebRequest();
                _inflightLoads.Add(new PendingLoad { path = item.path, category = item.category, request = request });

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] Queued audio load: {item.path} (type: {audioType})");
                }
            }

            for (int i = _inflightLoads.Count - 1; i >= 0; i--)
            {
                var load = _inflightLoads[i];
                if (load.request.isDone)
                {
                    if (string.IsNullOrEmpty(load.request.error))
                    {
                        AudioClip clip = DownloadHandlerAudioClip.GetContent(load.request);
                        if (clip != null)
                        {
                            clip.name = Path.GetFileName(load.path);
                            UnityEngine.Object.DontDestroyOnLoad(clip);
                            clip.hideFlags = HideFlags.DontUnloadUnusedAsset;
                            _audioClips[load.category].Add(clip);

                            // 音频加载完成后，重置对应阶段的可用索引列表
                            ResetAvailableIndicesForStage(load.category);

                            string loadTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                            if (_cfgEnableDebugLogging.Value)
                            {
                                L.LogDebug($"[{loadTime}] Loaded audio clip: {load.path} (length: {clip.length:F2}s)");
                            }
                        }
                        else
                        {
                            string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                            L.LogError($"[{errorTime}] Failed to load audio clip (null): {load.path}");
                        }
                    }
                    else
                    {
                        string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                        L.LogError($"[{errorTime}] Failed to load audio clip: {load.path} - {load.request.error}");
                    }

                    load.request.Dispose();
                    _inflightLoads.RemoveAt(i);
                }
            }
        }

        private void EnsureAudioSourceValid()
        {
            if (_audioHost == null || !_audioHost)
            {
                _audioHost = new GameObject("VoicePack_AudioHost");
                GameObject.DontDestroyOnLoad(_audioHost);

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] Recreated audio host object");
                }
            }

            if (_audioSource == null || !_audioSource)
            {
                _audioSource = _audioHost.GetComponent<AudioSource>() ?? _audioHost.AddComponent<AudioSource>();
                _audioSource.playOnAwake = false;
                _audioSource.spatialBlend = 0f;

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] Recreated audio source component");
                }
            }
        }

        private float GetDynamicPlayInterval(float baseInterval)
        {
            float rateFactor = 1f / (1f + _currentGrowthRate * _cfgGrowthRateSensitivity.Value);
            float dynamicInterval = baseInterval * rateFactor;
            dynamicInterval = Mathf.Clamp(dynamicInterval, _cfgMinPlayInterval.Value, _cfgMaxPlayInterval.Value);

            if (_cfgEnableDebugLogging.Value)
            {
                string calcTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogDebug($"[{calcTime}] Dynamic interval calculation: base={baseInterval:F3} → {dynamicInterval:F3} (rate: {_currentGrowthRate:F4}, factor: {rateFactor:F4})");
            }

            return dynamicInterval;
        }

        private void PlayCurrentLevelAudio(float unityTime, float currentEcstasy)
        {
            if (_currentLevel == -1 || _currentLevel == 3) return;

            // 游戏暂停时不播放
            if (Time.timeScale == 0f)
            {
                if (_cfgEnableDebugLogging.Value)
                {
                    string logTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogDebug($"[{logTime}] [UnityTime: {unityTime:F3}s] Game is paused, skipping {GetLevelName(_currentLevel)} audio playback");
                }
                return;
            }

            // Ecstasy增长判断
            bool isEcstasyGrowing = currentEcstasy > _previousEcstasy;
            bool hasRecentGrowth = _lastEcstasyChangeTime < 0 || (unityTime - _lastEcstasyChangeTime) < _cfgGrowthTimeout.Value;
            bool shouldPlay = _cfgGrowthTimeout.Value <= 0
                ? isEcstasyGrowing
                : isEcstasyGrowing || hasRecentGrowth;

            if (!shouldPlay)
            {
                if (_cfgEnableDebugLogging.Value)
                {
                    string logTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogDebug($"[{logTime}] [UnityTime: {unityTime:F3}s] Ecstasy not growing (current: {currentEcstasy:F4}, previous: {_previousEcstasy:F4}), skipping {GetLevelName(_currentLevel)} audio playback");
                }
                return;
            }

            string levelName = GetLevelName(_currentLevel);
            float baseInterval = _currentLevel switch
            {
                0 => _cfgLowBaseInterval.Value,
                1 => _cfgMediumBaseInterval.Value,
                2 => _cfgHighBaseInterval.Value,
                _ => 1f
            };

            float dynamicInterval = GetDynamicPlayInterval(baseInterval);
            float lastPlayed = _currentLevel switch
            {
                0 => _lastLowPlayed,
                1 => _lastMediumPlayed,
                2 => _lastHighPlayed,
                _ => 0f
            };

            if (unityTime - lastPlayed < dynamicInterval) return;

            PlayAudio(levelName, unityTime);

            if (_currentLevel == 0) _lastLowPlayed = unityTime;
            else if (_currentLevel == 1) _lastMediumPlayed = unityTime;
            else if (_currentLevel == 2) _lastHighPlayed = unityTime;
        }

        private void PlayAudio(string category, float unityTime)
        {
            string playTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");

            // 游戏暂停时不播放
            if (Time.timeScale == 0f)
            {
                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{playTime}] [UnityTime: {unityTime:F3}s] Game is paused, skipping {category} audio playback");
                }
                return;
            }

            // Climax等级增长判断
            if (category == "climax")
            {
                bool isEcstasyGrowing = CurrentPlayerEcstasy > _previousEcstasy;
                bool hasRecentGrowth = _lastEcstasyChangeTime < 0 || (unityTime - _lastEcstasyChangeTime) < _cfgGrowthTimeout.Value;
                bool shouldPlay = _cfgGrowthTimeout.Value <= 0
                    ? isEcstasyGrowing
                    : isEcstasyGrowing || hasRecentGrowth;

                if (!shouldPlay)
                {
                    if (_cfgEnableDebugLogging.Value)
                    {
                        L.LogDebug($"[{playTime}] [UnityTime: {unityTime:F3}s] Ecstasy not growing, skipping climax audio playback (current: {CurrentPlayerEcstasy:F4}, previous: {_previousEcstasy:F4})");
                    }
                    return;
                }
            }

            if (!_audioClips.ContainsKey(category) || _audioClips[category].Count == 0)
            {
                if (!_warnedEmptyCategories.Contains(category))
                {
                    L.LogWarning($"[{playTime}] [UnityTime: {unityTime:F3}s] No audio clips available for {category} category");
                    _warnedEmptyCategories.Add(category);
                }
                AttemptReloadCategory(category);
                return;
            }

            var clips = _audioClips[category].Where(c => c != null).ToList();
            if (clips.Count == 0)
            {
                L.LogWarning($"[{playTime}] [UnityTime: {unityTime:F3}s] All clips in {category} category are null");
                return;
            }

            // 核心升级：轮询逻辑（用完所有索引后重置）
            AudioClip clip;
            int selectedIndex;

            // 检查可用索引列表，为空则重置
            if (_availableClipIndicesPerStage[category].Count == 0)
            {
                ResetAvailableIndicesForStage(category);
                L.LogInfo($"[{playTime}] [UnityTime: {unityTime:F3}s] {category} stage audio pool exhausted - resetting round-robin list (total clips: {clips.Count})");
            }

            // 取第一个索引并移除（实现轮询）
            selectedIndex = _availableClipIndicesPerStage[category][0];
            _availableClipIndicesPerStage[category].RemoveAt(0);
            clip = clips[selectedIndex];

            if (_cfgEnableDebugLogging.Value)
            {
                L.LogDebug($"[{playTime}] [UnityTime: {unityTime:F3}s] Selected {category} audio (index: {selectedIndex}, remaining in pool: {_availableClipIndicesPerStage[category].Count}): {clip.name}");
            }

            _audioSource.PlayOneShot(clip);
            _lastAnyAudioPlayed = unityTime;

            L.LogInfo($"[{playTime}] [UnityTime: {unityTime:F3}s] Playing {category} audio: {clip.name} (length: {clip.length:F2}s, Ecstasy: {CurrentPlayerEcstasy:F4})");
        }

        private void SetNextPlayTime(float unityTime)
        {
            if (_currentLevel == -1 || _currentLevel == 3) return;

            string levelName = GetLevelName(_currentLevel);
            float baseInterval = _currentLevel switch
            {
                0 => _cfgLowBaseInterval.Value,
                1 => _cfgMediumBaseInterval.Value,
                2 => _cfgHighBaseInterval.Value,
                _ => 1f
            };

            float dynamicInterval = GetDynamicPlayInterval(baseInterval);
            float randomOffset = (float)(_rng.NextDouble() * 0.05f - 0.025f);
            _nextPlayTime = unityTime + dynamicInterval + randomOffset;

            if (_cfgEnableDebugLogging.Value)
            {
                string nextPlayTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogDebug($"[{nextPlayTime}] [UnityTime: {unityTime:F3}s] Next play time for {levelName}: {_nextPlayTime:F3}s (interval: {dynamicInterval:F3}s + offset: {randomOffset:F3}s)");
            }
        }

        private void AttemptReloadCategory(string category)
        {
            float now = Time.realtimeSinceStartup;
            if (now - _lastReloadAttempt[category] < 3f) return;
            _lastReloadAttempt[category] = now;

            string categoryPath = Path.Combine(Paths.PluginPath, PluginInfo.Name, "VoicePack");
            categoryPath = Path.Combine(categoryPath, category);
            if (!Directory.Exists(categoryPath)) return;

            if (_cfgEnableDebugLogging.Value)
            {
                string reloadTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogDebug($"[{reloadTime}] Reloading audio files for {category} category");
            }

            foreach (var file in Directory.GetFiles(categoryPath, "*.*"))
            {
                string ext = Path.GetExtension(file).ToLowerInvariant();
                if (ext == ".ogg" || ext == ".wav")
                {
                    _loadQueue.Enqueue((file, category));
                }
            }
        }
        #endregion

        #region 辅助方法
        private int GetLevelFromEcstasy(float ecstasy)
        {
            if (ecstasy >= _cfgHighThreshold.Value) return 2;
            if (ecstasy >= _cfgMediumThreshold.Value) return 1;
            if (ecstasy >= _cfgLowThreshold.Value) return 0;
            return -1;
        }

        private string GetLevelName(int level)
        {
            return level switch
            {
                0 => "low",
                1 => "medium",
                2 => "high",
                3 => "climax",
                _ => "unknown"
            };
        }

        private float GetLevelThreshold(int level)
        {
            return level switch
            {
                0 => _cfgLowThreshold.Value,
                1 => _cfgMediumThreshold.Value,
                2 => _cfgHighThreshold.Value,
                3 => _cfgClimaxThreshold.Value,
                _ => 0f
            };
        }

        private void TryResolveControllerEcstasyGetter(Type controllerType)
        {
            try
            {
                var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;

                var prop = controllerType.GetProperty(PreferredEcstasyMember, flags);
                if (prop != null && (prop.PropertyType == typeof(float) || prop.PropertyType == typeof(double)))
                {
                    var getMethod = prop.GetGetMethod(true);
                    if (getMethod != null)
                    {
                        _controllerEcstasyGetter = obj => Convert.ToSingle(getMethod.Invoke(obj, null));
                        string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                        L.LogInfo($"[{bindTime}] Bound controller property: {controllerType.FullName}.{prop.Name}");
                        return;
                    }
                }

                var field = controllerType.GetField(PreferredEcstasyMember, flags);
                if (field != null && (field.FieldType == typeof(float) || field.FieldType == typeof(double)))
                {
                    _controllerEcstasyGetter = obj => Convert.ToSingle(field.GetValue(obj));
                    string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                    L.LogInfo($"[{bindTime}] Bound controller field: {controllerType.FullName}.{field.Name}");
                    return;
                }

                foreach (var p in controllerType.GetProperties(flags))
                {
                    if (p.PropertyType != typeof(float) && p.PropertyType != typeof(double)) continue;

                    bool hasEcstasy = p.Name.IndexOf("Ecstasy", StringComparison.OrdinalIgnoreCase) >= 0;
                    bool hasTime = p.Name.IndexOf("Time", StringComparison.OrdinalIgnoreCase) >= 0;

                    if (hasEcstasy && !hasTime)
                    {
                        var getMethod = p.GetGetMethod(true);
                        if (getMethod != null)
                        {
                            _controllerEcstasyGetter = obj => Convert.ToSingle(getMethod.Invoke(obj, null));
                            string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                            L.LogWarning($"[{bindTime}] Fuzzy-bound controller property (value): {controllerType.FullName}.{p.Name}");
                            return;
                        }
                    }
                }

                foreach (var f in controllerType.GetFields(flags))
                {
                    if (f.FieldType != typeof(float) && f.FieldType != typeof(double)) continue;

                    bool hasEcstasy = f.Name.IndexOf("Ecstasy", StringComparison.OrdinalIgnoreCase) >= 0;
                    bool hasTime = f.Name.IndexOf("Time", StringComparison.OrdinalIgnoreCase) >= 0;

                    if (hasEcstasy && !hasTime)
                    {
                        _controllerEcstasyGetter = obj => Convert.ToSingle(field.GetValue(obj));
                        string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                        L.LogWarning($"[{bindTime}] Fuzzy-bound controller field (value): {controllerType.FullName}.{f.Name}");
                        return;
                    }
                }

                string warnTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogWarning($"[{warnTime}] No valid Ecstasy value member found on controller");
            }
            catch (Exception ex)
            {
                string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogError($"[{errorTime}] Failed to resolve controller Ecstasy getter: {ex.Message}");

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{errorTime}] Getter resolution exception: {ex.StackTrace}");
                }
            }
        }

        private void TryFuzzyEcstasySearch(object root)
        {
            if (root == null) return;

            try
            {
                var visited = new HashSet<object>(new ReferenceEqualityComparer());
                var queue = new Queue<object>();
                queue.Enqueue(root);
                visited.Add(root);

                while (queue.Count > 0)
                {
                    var current = queue.Dequeue();
                    if (current == null) continue;

                    Type type = current.GetType();
                    if (type.IsPrimitive || type == typeof(string) ||
                        type.Name.Contains("Il2CppReferenceArray") ||
                        type.Name.Contains("Il2CppArray"))
                    {
                        continue;
                    }

                    var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

                    foreach (var prop in type.GetProperties(flags))
                    {
                        try
                        {
                            if (prop.GetIndexParameters().Length != 0) continue;
                            var getMethod = prop.GetGetMethod(true);
                            if (getMethod == null) continue;

                            object value = getMethod.Invoke(current, null);
                            if (value == null) continue;

                            if (prop.PropertyType == typeof(float) || prop.PropertyType == typeof(double))
                            {
                                bool hasEcstasy = prop.Name.IndexOf("Ecstasy", StringComparison.OrdinalIgnoreCase) >= 0;
                                bool hasTime = prop.Name.IndexOf("Time", StringComparison.OrdinalIgnoreCase) >= 0;

                                if (hasEcstasy && !hasTime)
                                {
                                    _fallbackEcstasyGetter = () => Convert.ToSingle(getMethod.Invoke(current, null));
                                    string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                                    L.LogWarning($"[{bindTime}] Deep fuzzy match: {type.FullName}.{prop.Name}");
                                    return;
                                }
                            }

                            if (!visited.Contains(value) && !IsPrimitiveType(value.GetType()))
                            {
                                visited.Add(value);
                                queue.Enqueue(value);
                            }
                        }
                        catch { continue; }
                    }

                    foreach (var field in type.GetFields(flags))
                    {
                        try
                        {
                            object value = field.GetValue(current);
                            if (value == null) continue;

                            if (field.FieldType == typeof(float) || field.FieldType == typeof(double))
                            {
                                bool hasEcstasy = field.Name.IndexOf("Ecstasy", StringComparison.OrdinalIgnoreCase) >= 0;
                                bool hasTime = field.Name.IndexOf("Time", StringComparison.OrdinalIgnoreCase) >= 0;

                                if (hasEcstasy && !hasTime)
                                {
                                    _fallbackEcstasyGetter = () => Convert.ToSingle(field.GetValue(current));
                                    string bindTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                                    L.LogWarning($"[{bindTime}] Deep fuzzy match: {type.FullName}.{field.Name}");
                                    return;
                                }
                            }

                            if (!visited.Contains(value) && !IsPrimitiveType(value.GetType()))
                            {
                                visited.Add(value);
                                queue.Enqueue(value);
                            }
                        }
                        catch { continue; }
                    }
                }
            }
            catch (Exception ex)
            {
                string errorTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogError($"[{errorTime}] Fuzzy search failed: {ex.Message}");

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{errorTime}] Fuzzy search exception: {ex.StackTrace}");
                }
            }
        }

        private bool IsPrimitiveType(Type type)
        {
            return type.IsPrimitive || type == typeof(string) || type.IsEnum || type.IsValueType;
        }

        private void LogNotFoundThrottled(string message)
        {
            float now = Time.realtimeSinceStartup;
            if (now - _lastNotFoundLog >= 2f)
            {
                string logTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                L.LogWarning($"[{logTime}] [UnityTime: {now:F3}s] {message}");
                _lastNotFoundLog = now;
            }
        }

        internal void DirectFeedEcstasy(float value)
        {
            string feedTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
            float unityTime = Time.realtimeSinceStartup;

            CurrentPlayerEcstasy = Mathf.Clamp01(value);
            _lastDirectEcstasyFeed = unityTime;

            if (_cfgEnableDebugLogging.Value)
            {
                L.LogDebug($"[{feedTime}] [UnityTime: {unityTime:F3}s] DirectFeedEcstasy - New value: {value:F4} (Previous: {_previousEcstasy:F4})");
            }

            if (value > _previousEcstasy)
            {
                _lastEcstasyChangeTime = _lastDirectEcstasyFeed;

                if (_cfgEnableDebugLogging.Value)
                {
                    L.LogDebug($"[{feedTime}] [UnityTime: {unityTime:F3}s] Updated Ecstasy change time to: {_lastEcstasyChangeTime:F3}s");
                }
            }
        }
        #endregion

        #region Harmony Patch Callbacks
        public static void OnPlayerEcstasyControllerUpdate(object __instance)
        {
            Instance?.Tick(__instance);
        }
        #endregion

        private sealed class ReferenceEqualityComparer : IEqualityComparer<object>
        {
            public new bool Equals(object x, object y) => ReferenceEquals(x, y);
            public int GetHashCode(object obj) => obj == null ? 0 : RuntimeHelpers.GetHashCode(obj);
        }
    }
}
